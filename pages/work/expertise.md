---
title: "Expertise"
meta_content: "Nate Eagleson's areas of expertise in software development."
template: "essay.html.tmpl"
draft: yes
---

What am I good at in software development?

- Programming. Give me a passable spec and some time to myself and I'll give
  you a working implementation of the spec. I'll also come back to you promptly
  when I notice inconsistencies or shortcomings in the spec with the best
  suggestion I've got for fixing it. I've got a track record of doing that
  anywhere from the CLI to the web stack.

- Specifying. If you sit me down with some people who use the system (or who
  use a system you're hoping to replace), I can figure out what they need to
  replace it and I can write that down in a form other developers will be able
  to work with.

- Polishing. Given a basic UX design, spec, interface, or running program, I
  can streamline it to work more smoothly than it currently does (if it's a
  rough draft and/or we don't need backwards compatibility, sometimes much more
  smoothly). Little UX annoyances almost cause me physical pain (which is
  actually why I'm an Emacs user - it lets me fix those annoyances more quickly
  and easily than anything else I've ever encountered, and the rest of the
  community has a value for that too)

- Mentoring. I'm good at working with both junior and senior devs, seeing ways
  they can improve, and giving them kind, constructive feedback to help them do
  exactly that (as long as they're willing to listen and engage with
  questions). I'm also good at recognizing where someone else has more
  experience or expertise than I do in a given subject and learning from them.

- Tooling. I care deeply about the day-to-day developer experience on a
  project. It mainly manifests in automation, though also in my careful
  attention to project documentation. I thus have an interest in and opinions
  on everything from developer sandbox creation to version control / version
  control workflows. I have a good grasp of the different options and know when
  to apply which ones. I also have a strong interest in improving VCS and have
  strong opinions on how to do that - Git is not the end-all and be-all.

- Reading code. Many teams I've been on have been impressed with my ability to
  see subtleties about code rapidly. As a result, I've often wound up in the
  role of "guy who picks apart, documents, and repairs hairballs," (which I
  don't love being stuck on but am good at) as well as doing a lot of heavy
  code review work (which I really enjoy - I'm that guy who gets a monster PR
  and fills it with questions instead of saying "LGTM" and telling them to
  merge it).

- Documenting. Automation is better than documentation, but there are still
  plenty of places where clear written words are crucial. I'm a good technical
  writer who understands and empathizes with the different audiences I may need
  to communicate with in any software project (other devs, end users, project
  management, tech support, non-technical team members). As a programmer, I'm a
  strong believer in self-documenting programs and aim to create them wherever
  feasible.

- Systems administration / devops. I have a lot of the core skills and have a
  heavy dev background. I'm good with bash and the standard Unix tools. I've
  used Ansible and bash to largely automate server provisioning and dev sandbox
  setup. I understand why logs matter and how to aggregate them with syslog /
  logrotate, as well as how to analyze those aggregated logs with bash and Unix
  tools. I understand that QA and monitoring are the same thing, as Steve Yegge
  puts it, and have put that into practice at multiple jobs by adapting project
  test suites to monitor production systems.

- Data processing / wrangling. I'm not a data scientist, but I've extracted
  plenty of useful information from the goldmine which is webserver logs (and
  occasionally other system logs, too). I mostly use bash for that, because hot
  dang you can extract a lot of signal with just a few characters of pipeline,
  GNU Parallel is magic, and yourdatafitsinram.net. I understand that an
  analysis you can't reproduce is one whose flaws will go uncaught and unfixed,
  so I tend towards a literate-programming / reproducible research style when
  I'm doing data analysis.

So where does that leave me for my sales pitch as a dev?

I guess that I'm a very competent all-arounder and a really good candidate for
a team lead - I can help out with almost any aspect of a project, be it API
design, database schema layout, backend optimization, webserver configuration,
